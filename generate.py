#!/usr/bin/env python

import re
import os
import sys

asm_files = [
    "src/isprime.S"
]

source_paths = [
    "src/asmtypes.hpp",
    "src/bitalloc.hpp",
    "src/bitalloc.cpp",
    "src/micro_math.hpp",
    "src/micro_math.cpp",
    "src/similarity.hpp",
    "src/similarity.cpp",
    "src/neural.hpp",
    "src/neural.cpp",
    "src/ai.hpp",
    "src/ai.cpp"
]

def convert_asm_to_hpp(asm_path):
    try:
        with open(asm_path, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f"ERROR: Assembly source file not found: {asm_path}", file=sys.stderr)
        sys.exit(1)

    func_name = None
    asm_instructions = []

    for line in lines:
        stripped_line = line.strip()
        if not stripped_line or stripped_line.startswith(';'):
            continue # Skip empty lines and comments

        # Extract function name from .globl directive
        if stripped_line.startswith('.globl'):
            func_name = stripped_line.split()[-1]
            continue # Don't include the .globl directive itself

        # Filter out other assembler directives
        if stripped_line.startswith(('.text', '.section')):
            continue

        # Keep the core assembly instruction
        asm_instructions.append(stripped_line)

    if not func_name:
        print(f"ERROR: Could not find .globl directive in {asm_path}", file=sys.stderr)
        sys.exit(1)

    all_asm_lines = [".intel_syntax noprefix"] + asm_instructions + [".att_syntax prefix"]

    # Format each instruction as its own C++ string literal.
    formatted_lines = []
    for i, instruction in enumerate(all_asm_lines):
        # Escape characters that have special meaning in C++ strings.
        escaped_instruction = instruction.replace('\\', '\\\\').replace('"', '\\"')

        # All lines except the very last one need a newline for the assembler.
        if i < len(all_asm_lines) - 1:
            formatted_lines.append(f'        "{escaped_instruction}\\n\\t"')
        else:
            # The last line doesn't need a trailing newline.
            formatted_lines.append(f'        "{escaped_instruction}"')

    formatted_asm = '\n'.join(formatted_lines)

    hpp_filename = os.path.basename(asm_path).replace('.S', '.hpp')
    hpp_guard = hpp_filename.upper().replace('.', '_')

    hpp_content = f"""#ifndef {hpp_guard}
#define {hpp_guard}

/*
    NOTE: This file is auto-generated by generate.py from {os.path.basename(asm_path)}.
    Do not edit this file directly.
*/

// Only enable for GCC/Clang on x86-64 where this syntax is valid.
#if defined(__GNUC__) && defined(__x86_64__)

namespace include_ai {{

// The 'naked' attribute tells GCC not to generate a function prologue/epilogue,
// as we provide it ourselves in the assembly code.
__attribute__((naked))
int {func_name}(int n) {{
    // The 'volatile' keyword prevents the compiler from optimizing this block away.
    __asm__ __volatile__(
        {formatted_asm}
    );
}}

}} // namespace include_ai

#endif // __GNUC__ && __x86_64__

#else // {hpp_guard}
  #error \"double include\"
#endif // {hpp_guard}
"""
    return hpp_content, hpp_filename

for asm_path in asm_files:
    hpp_code, hpp_basename = convert_asm_to_hpp(asm_path)

    # Construct the full path for the new .hpp file inside the 'src' directory
    hpp_path = os.path.join(os.path.dirname(asm_path), hpp_basename)

    with open(hpp_path, 'w') as f:
        f.write(hpp_code)

    print(f"  - Generated {hpp_path} from {asm_path}")

    # Add the newly generated file to the list of sources to be processed
    source_paths.append(hpp_path)
print("---------------------------------\n")

def find_local_includes(filepath):
    """Parses a file and returns a list of its local #include'd filenames."""
    # This regex finds lines like '#include "some_file.hpp"'
    include_regex = re.compile(r'#\s*include\s*"([^"]+)"')
    dependencies = []
    try:
        with open(filepath, 'r') as f:
            for line in f:
                match = include_regex.search(line)
                if match:
                    # 'match.group(1)' is the content inside the quotes
                    dependencies.append(os.path.basename(match.group(1)))
    except FileNotFoundError:
        print(f"Warning: Could not find file {filepath} to parse for dependencies.")
    return dependencies

# Create a map of basename -> full path for easy lookup, e.g., {"ai.hpp": "src/ai.hpp"}
basename_to_path = {os.path.basename(p): p for p in source_paths}

files = []
for path in source_paths:
    # Find basenames of included files (e.g., "ai.hpp", "asmtypes.hpp")
    included_basenames = find_local_includes(path)
    # Convert those basenames back to the full project paths from our list
    deps = [basename_to_path[b] for b in included_basenames if b in basename_to_path]
    # Add the file and its resolved dependencies to our list
    files.append((path, deps))
    if deps:
        print(f"  - {path} depends on: {', '.join(deps)}")
print("---------------------------------\n")


def topological_sort(files_with_deps):
    # Create the dependency graph as an adjacency list
    graph = {item: deps for item, deps in files_with_deps}
    sorted_files = []
    # Sets to keep track of visited nodes
    visited = set()         # Nodes that have been fully processed
    recursion_stack = set() # Nodes currently in the recursion stack (for cycle detection)

    def visit(file):
        # If we encounter a node that's already in the recursion stack, we have a cycle.
        if file in recursion_stack:
            print(f"ERROR: Circular dependency detected involving {file}", file=sys.stderr)
            sys.exit(1)

        # If the node has already been fully processed, we don't need to do anything.
        if file in visited:
            return

        # Mark the node as being visited in the current recursion path.
        recursion_stack.add(file)

        # Recursively visit all dependencies (neighbors in the graph).
        if file in graph:
            for dependency in graph[file]:
                visit(dependency)

        # All dependencies of 'file' have been processed.
        # Now, remove it from the recursion stack and mark it as fully visited.
        recursion_stack.remove(file)
        visited.add(file)

        # Add the file to the final sorted list.
        # Since we add it *after* its dependencies, the result will be in the correct order.
        sorted_files.append(file)

    # Visit every file in the original list to ensure all are included
    for file, _ in files_with_deps:
        if file not in visited:
            visit(file)

    # The `sorted_files` list is now topologically sorted. We need to get the
    # full (file, deps) tuple back for the rest of the script.
    file_map = {item: deps for item, deps in files_with_deps}
    return [(file, file_map[file]) for file in sorted_files]



unique = topological_sort(files)
for c in unique:
    print(c[0]+" - "+" ".join(c[1]))

merge_result = """/*
    You must add '#define INCLUDEAI_IMPLEMENTATION' before '#include'ing this in ONE source file.
    Like this:
        #define INCLUDEAI_IMPLEMENTATION
        #include \"includeai.hpp\"

    AUTHOR
        Pitiless Peanut (aka. Shaiden Spreitzer, Professor Peanut, etc...) of VECTORPHASE

    LICENSE
        BSD 4-Clause (See end of file)
*/\n\n"""

license = """\n/*
Copyright (c) 2025, VECTORPHASE Systems
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. All advertising materials mentioning features or use of this software must
   display the following acknowledgement:
     This product includes software developed by VECTORPHASE

4. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
EVENT SHALL COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/\n
"""

merge_result += "#ifndef INCLUDEAI_HPP\n#define INCLUDEAI_HPP\n\n"
merge_result += "#ifdef INCLUDEAI_IMPLEMENTATION\n\n\n"
merge_result += """#include <cmath>
#include <concepts>
#if defined(AI_DEBUG)
  #include <assert.h>
#endif
#if defined(__AVX__) || defined(__AVX2__) || defined(__AVX512F__) || defined(__SSSE3__)
  #include <immintrin.h>
#elif defined(__ARM_NEON)
  #include <arm_neon.h>
#elif defined(__wasm_simd128__)
  #include <wasm_simd128.h>
#else
  #error "unknown arch! (use '-msimd128' to fix)"
#endif\n\n
namespace include_ai {\n\n\n
"""

remove = ["#include", "_HPP", "double include", "AVX", "NEON", "defined(__wasm_simd128__)", "nothing?", "unknown", "namespace include_ai"]

for filename, _ in unique: # 'unique' tuple is unpacked as (filename, dependencies)
    f = open(filename, "r")
    lines = f.readlines()
    for code_line in lines:
        if any(x in code_line for x in remove):
            pass
        else:
            merge_result += code_line
    merge_result += "\n\n"

merge_result += """} // namespace include_ai\n\n\n
#endif // INCLUDEAI_IMPLEMENTATION\n\n
#endif // INCLUDEAI_HPP\n
"""
merge_result += license

open("./includeai.hpp", "w+").write(merge_result + "\n")

print("success")
